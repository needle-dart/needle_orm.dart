class NumberField {}

/*
// sql example generated by Ebean

select distinct 
t0.id, t0.uuid, t0.remark, t0.login_name, t0.user_name, t0.user_type, t0.email, t0.phonenumber, t0.sex, t0.avatar, t0.password, t0.salt, t0.status, t0.login_ip, t0.login_date, t0.pwd_update_date, t0.create_by, t0.create_time, t0.update_by, t0.update_time, t0.deleted, t1.id, t0.dept_id 
from sys_user t0 
left join dy_member t1 on t1.user_id = t0.id and t1.deleted = 0 
left join sys_user_role u1z_ on u1z_.user_id = t0.id 
left join sys_role u1 on u1.id = u1z_.role_id 
where t0.login_name like '%a%' escape'|'  and u1.role_sort > ? and (t0.login_name = ? or u1.status = ?) and t0.deleted = 0;
*/

class Query {
  final bool distinct;
  List<String> columns = [];
  String tableName;
  final String alias;
  List<Join> joins = [];
  And conditions = And();

  Query(this.tableName, this.alias, {this.distinct = false});

  String toSql() {
    return [
      'select',
      distinct ? 'distinct' : '',
      columns.join(', '),
      'from',
      tableName,
      alias,
      joins.toSql(),
      conditions.isNotEmpty ? 'where ' + conditions.toSql(wrap: false) : ''
    ].where((element) => element.isNotEmpty).join(' ');
  }
}

class Join {
  final String tableName;
  final String alias;
  final JoinType joinType;
  ConditionGroup conditions = And();

  Join(this.tableName, this.alias, [this.joinType = JoinType.INNER]);

  String toSql() {
    return [
      _joinType(),
      'join',
      tableName,
      alias,
      'on',
      conditions.toSql(wrap: false)
    ].where((element) => element.isNotEmpty).join(' ');
  }

  String _joinType() {
    switch (joinType) {
      case JoinType.INNER:
        return '';
      default:
        return joinType.name;
    }
  }

  Map<String, dynamic> get params => conditions.params;
}

extension JoinGroup on List<Join> {
  String toSql() {
    return this.map((j) => j.toSql()).join(' ');
  }

  Map<String, dynamic> get params => _params();

  Map<String, dynamic> _params() {
    return this
        .fold(<String, dynamic>{}, (map, join) => map..addAll(join.params));
  }
}

enum JoinType { INNER, LEFT, RIGHT, FULL }

// u1.role_sort > ?
// t1.deleted = 0
class Condition {
  final String stmt;

  final Map<String, dynamic> params = {};

  Condition(this.stmt, [Map<String, dynamic>? params = null]) {
    if (params != null) {
      this.params.addAll(params);
    }
  }

/*   bool get isGroup =>
      oper == ConditionOper.AND ||
      oper == ConditionOper.OR ||
      oper == ConditionOper.NOT;
 */

  String toSql() {
    return stmt;
  }
}

class ConditionGroup extends Condition {
  final ConditionOper oper;

  final List<Condition> conditions = [];

  ConditionGroup(this.oper, {List<Condition>? conditions = null}) : super('') {
    if (conditions != null) {
      this.conditions.addAll(conditions);
      conditions.forEach((element) {
        params.addAll(element.params);
      });
    }
  }

  bool get isEmpty => conditions.isEmpty;
  bool get isNotEmpty => conditions.isNotEmpty;

  ConditionGroup operator +(Condition condition) {
    return append(condition);
  }

  ConditionGroup append(Condition condition) {
    conditions.add(condition);
    params.addAll(condition.params);
    if (oper == ConditionOper.NOT) {
      assert(conditions.length <= 1);
    }
    return this;
  }

  @override
  String toSql({bool wrap: true}) {
    if (oper == ConditionOper.NOT) return " NOT ( ${conditions[0].toSql()} ) ";
    var str = conditions.map((c) => c.toSql()).join(' ${oper.name} ');
    return wrap ? '($str)' : str;
  }
}

class And extends ConditionGroup {
  And([List<Condition>? conditions])
      : super(ConditionOper.AND, conditions: conditions);
}

class Or extends ConditionGroup {
  Or([List<Condition>? conditions])
      : super(ConditionOper.OR, conditions: conditions);
}

class Not extends ConditionGroup {
  Not([Condition? condition]) : super(ConditionOper.NOT) {
    if (condition != null) {
      this.conditions.add(condition);
    }
  }
}

enum ConditionOper {
  EQ,
  GT,
  LT,
  LIKE,
  GE,
  LE,
  IN,
  NOT_IN,
  IS_NULL,
  IS_NOT_NULL,
  // EXISTS,
  // NOT EXISTS,
  AND,
  OR,
  NOT,
}
